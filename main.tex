\input{template.tex}
\usepackage{fancyvrb, framed, verbatim}
\usepackage{listings}
\usepackage[T1]{fontenc}
\definecolor{shadecolor}{rgb}{.9, .9, .9}  %These were defined for when I used to use the verbatim environment, they are not used now normally.
\newenvironment{code} %
   {\snugshade\verbatim}%
   {\endverbatim\endsnugshade}


\lstset{ 
  language=C,
  backgroundcolor=\color[rgb]{0.1,0.1,0.1},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  showstringspaces=false,          % So that it hides the spaces in strings
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  firstnumber=1,                % start line enumeration with line 1
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{gray}, % the style that is used for the line-numbers
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  tabsize=2,	                   % sets default tabsize to 2 spaces
  commentstyle=\color{YellowGreen},    % comment style
  stringstyle=\color{DarkOrchid},     % string literal style
 % keywordstyle=\color{ForestGreen},       % keyword style
  upquote=true                     %Fixing the quotes
}

\pagecolor[rgb]{0.1,0.1,0.1} %page colour is frosted screen black
\color[rgb]{0,0.6,0} %text colour is phosphor green



\title{Rust Course notes}
\author{Razafy Rindra, ``Hagamena''}

\begin{document}

\maketitle
\tableofcontents
\newpage
\section{Introduction}
Some quick notes from the Rust book, and the ``Let's Get Rusty'' \href{https://youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8}{online course}
\section{Common Programming Concepts in Rust}
\subsection{Variables and Mutability}
\subsubsection{Mutable variables} 
Variables in Rust are immmutable by default. In order to createe a mutable variable, we need to add in `mut' in front of the name like so:
\begin{lstlisting}
    fn main() {
        let mut x = 5;
        println!("The value of x is: {x}");
        x = 6;
        println!("The value of x is: {x}"); 
}
\end{lstlisting}


\subsubsection{Constants} We can also declare constants in Rust like so:
\begin{lstlisting}
    const my_number: u32 = 100_000;
\end{lstlisting}

Constants unlike variables can't be mutable, need to be type annotated and they can't be assigned to return value of a function or any value computed at run time.

\subsubsection{Shadowing}
Shadowing allows us to create a new variable with an existing name, for example:
\begin{lstlisting}
    let x = 5;
    println!("The value of x is: {x}");
    let x = "six";
    println!("The value of x is: {x}");
\end{lstlisting}

\subsection{Data Types}
\begin{definition}
    \textbf{Scalar data types} represent a single value, \textbf{Compound data types} represent a goup of values
\end{definition}
Types of scalar data types\begin{enumerate}
    \item Integers, they can be 8,16,32,64,128 bit signed or unsigned integers.
    \item Floating-point numbers
    \item Booleans
    \item Character, they represent unicode character
\end{enumerate}
Type of compound data types\begin{enumerate}
    \item Tuples; a fixed size array of data that can be of different values.
    \begin{lstlisting}
        let tup = ("Let's Get Rusty!",100_000);
    \end{lstlisting}
    \item Arrays, in Rust they are fixed length.
\end{enumerate}
\subsection{Functions}
Functions are defined with an fn keyword like so:\begin{lstlisting}
    fn my_function(x: i32,y: i32){
         println!("The value of x is: {}", x);
         println!("The value of y is: {}", y);
    }
\end{lstlisting}

A piece in code in Rust are either a statement or an expression. Statements perform some action but do not return any value, whilst expressions returns values. 
\begin{lstlisting}
    fn my_function(x: i32,y: i32) -> i32{
         println!("The value of x is: {}", x);
         println!("The value of y is: {}", y);
         x+y
    }
\end{lstlisting}

In this function, the println are statements since they don't return anything while `x+y' is an expression, it is returned by the function (note the last expression of a function is implicitely returned). 

\subsection{Control Flow}
\subsubsection{if statements}
As in other programming languages:\begin{lstlisting}
 fn main() {
    let number = 3;

    if number < 5 {
        println!("first condition was true");
    } else if number < 22{
        println!("second condition was true.")
    }else{
        println!("condition was false");
    }
}
\end{lstlisting}
Note, the condition must be a boolean. We can also set a ``if-else'' statement in a let statemetn.\begin{lstlisting}
    fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
\end{lstlisting}
\subsubsection{Loops}
We can create loops with the `loop' keyword, which will execute the code in it until we call break.\begin{lstlisting}
    let mut counter = 0;
    let result = loop{
       counter += 1;
       if counter == 10{
            break counter;
       }
    };
\end{lstlisting}

We can also use the while statement:\begin{lstlisting}
    let mut number = 3;
    while number != 0{
        println!("{}!", number);
        number -= 1;
    }
\end{lstlisting}

Finally the third type of loop we can create are `for loops'\begin{lstlisting}
    let a = [10,20,30,40,50];
    
    for element in a.iter{
        println!("The value is: {}", element);
    }
\end{lstlisting}

We can also loop over a range:\begin{lstlisting}
    for number in 1..4{
        println!("{}!", number);
    }
\end{lstlisting}
The last number of the range is excluded.
\section{Ownership}
\paragraph*{What is ownership?}
The ownership model is a way to manage memory. How do we manage memory today?\begin{enumerate}
    \item Garbage collection.
Used in high level languages like java or $C\#$, the Garbage collection manages memory for you.
It's pros is that is error free, you don't have to manage memory yourself so you won't introduce memory bugs. It also faster write time.

It's cons is that you have no control over memory, it is slower and has unpredictable runtime performance and larger program size since you got to include a garbage collector.

    \item Manual memory management
    
It's pros are that you have higher control over memory, faster runtime and smaller program size. But it is error prone and has slower writing time.

Notice that these two have opposite trade-offs.

    \item Ownership model
    
This is the way Rust manages memory, it's pros are control over memory, faster runtime and smaller program size and is error free (though it does allow for you to opt-out of memory safetey).
It's cons is that you have a slower write time, slower than with Manual memeory management, Rust has a strict set of rules around memory management.
\end{enumerate}

\paragraph*{Stack and Heap}
During runetime program has access of stack and heap, stack is fixed size and cannot grow or shrink during runetime and it creates stack-frames for each function 
it executes. Each stack frames stores the local variables of the function they execute, their size are calculated during compile time and variables in stack frames 
only live as long as the stack lives.

\

The heap grows and shrinks during runtime and the data stored can be dynamic in size and we control the lifetime of the data.

Pushing to the stack is faster than allocating on the heap since the heap has to spend time looking for a place to store the data, also accessing data on the stack is faster 
than accessing data on the heap, since on the heap we must follow the pointer.

\begin{lstlisting}
    let x = "hello";
\end{lstlisting}
This is a string litteral and has fixed size and is stored in the stack-frame.

\begin{lstlisting}
    let x = String::from(world");
\end{lstlisting}
x is of type String which can be dynamic in size so it can't be stored on the stack, we ask the heap to allocate memory for it 
and it passes back a pointer, which is what is stored on the stack. 

\subsection{Ownership Rules}

\begin{enumerate}
    \item Each value in Rust has a variable called its owner.
    \item There can only be one owner at a time.
    \item When the owner goes out of scope, the value will be dropped.
\end{enumerate}

\begin{example}

    \

    \begin{lstlisting}
        fn main(){
            let x = 5;
            let y = x; // Copy

            let s1 = String::from("hello");
            let s2 = s1; // move (not a shallow copy)

            println!("{}, world", s1);
        }
    \end{lstlisting}
This returns an error since when we created s2 we made it point to the same ``hello'' on the heap that s1 points to, but in order to 
ensure memory safetey, Rust invalidates s1. 

What if we do want to clone the string? Use the clone() method: \begin{lstlisting}
    fn main(){
        let x = 5;
        let y = x; // Copy

        let s1 = String::from("hello");
        let s2 = s1.clone();

        println!("{}, world", s1);
    }
\end{lstlisting}
\end{example}

\subsection{Ownership and functions}
\begin{example}

    \

    \begin{lstlisting}
        fn main(){
            let s = String::from("hello);
            takes_ownership(s);
            println!("{}", s);
        }

        fn takes_ownership(some_string: String){
            println!("{}", some_string);
        }
    \end{lstlisting}

This gives us an error since after we pass a parameter in a function it is the same as if we assign the parameter to another variable.

So we move s into some\_string and after takes\_ownership scope is done some\_string is dropped.

\begin{example}
    
    \

    \begin{lstlisting}
        fn main() {
            let s1 = gives_ownership();
            println!("s1 = {}", s1);
        }

        fn gives_ownership(){
            let some_string = String::from("hello");
            some_string // returning the string moves ownership to s1
        }
    \end{lstlisting}
\end{example}
\begin{example}
    
    \

    \begin{lstlisting}
        fn main() {
        let s1 = gives_ownership();         // gives_ownership moves its return
                                            // value into s1
    
        let s2 = String::from("hello");     // s2 comes into scope
    
        let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                            // takes_and_gives_back, which also
                                            // moves its return value into s3
    } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
      // happens. s1 goes out of scope and is dropped.
    
    fn gives_ownership() -> String {             // gives_ownership will move its
                                                 // return value into the function
                                                 // that calls it
    
        let some_string = String::from("yours"); // some_string comes into scope
    
        some_string                              // some_string is returned and
                                                 // moves out to the calling
                                                 // function
    }
    
    // This function takes a String and returns one
    fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                          // scope
    
        a_string  // a_string is returned and moves out to the calling function
    }
    \end{lstlisting}
    

\end{example}

Moving ownership and giving back is tedious, what if we just want to use variable without taking ownership? Use references.

\end{example}
\subsection{References}

Let us see how references fix the following situation\begin{lstlisting}
    fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
\end{lstlisting}

Here in order to calculate the length of the string without taking ownershipe, we need to return a tuple that returns both the string and the length.

\begin{lstlisting}
    fn main() {
        let s1 = String::from("hello");
    
        let len = calculate_length(&s1);
    
        println!("The length of '{}' is {}.", s1, len);
    }
    
    fn calculate_length(s: &String) -> usize {
        let length = s.len(); // len() returns the length of a String
        length 
    }
\end{lstlisting}

Here s is a reference of a string and takes no ownership of the string, it points to s1 which points to the string.
So when the function finishes executing s is dropped without affecting s1.

\begin{definition}
    Passing in references as function paramaters is called \textbf{borrowing}. Since we are not taking ownership of the parameters.
\end{definition} 
Note that references are immutable by default, so how to we modify value without taking ownership?

Mutable references:

\begin{lstlisting}
    fn main() {
    let mut s1 = String::from("hello");

    change(&mut s1);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
\end{lstlisting}

Now change can mutate the value of s1 without taking ownership. Mutable reference have a restriction, we can only have one mutable reference to a particular piece of data 
in a particular scope.

\newpage

\begin{lstlisting}
    fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s; // Returns an error since can not borrow twice.

    println!("{}, {}", r1, r2);
}
\end{lstlisting}

This prevents ``data races'' where two pointers point at the same data and one pointer reads the data and another one tries to write to the data.


What if we try to mix mutable and immutable references? We get another error, we can't have mutable reference if an immutable referece already exists. Immuatble reference don't expect the underlying data to change.
But we can have many Immuatble references, since we don't expect the underlying value to change.

Note the scope of a reference starts when it introduced and ends when it's used for the last time, so we can define a mutable reference when all the immuatble references are out of scope(so after we use them for the last time).

\paragraph*{Rules of Refences}\begin{enumerate}
    \item At any given time, we can either have one mutable reference or any number of immuatble reference.
    \item References must always be valid.
\end{enumerate}

\subsection{Slices}

\begin{definition}
    Slices let you a contiguous sequence of elements in a collection instead of the whole collection, without taking ownership.
\end{definition}

\begin{lstlisting}
    fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

fn main() {}
\end{lstlisting}

There are two problems with this, the return value of first\_word is not tied to the string.
If we change the string, the value of the length of the first word doesn't change.

If we wanted to return the second word, we must retrurn a tuple with the index at the start of the word and the index at the end of the word.
We have more values we must keep in sync.

Let us use the string slice:

\begin{lstlisting}
    fn main() {
    let mut s = String::from("hello world");

    let hello = &s[..5]; //String Slices, tells us we want the value of the string from index 0 to 4
    let world = &s[6..]; //String Slices, tells us we want the value of the string from index 6 to 10
    
    let s2 = "hello word"; // String litteral are string slices!

    let word = first_word(s2);

    fn first_word(s: &str) -> &str {
        let bytes = s.as_bytes();
    
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &s[0..i];
            }
        }
    
        &s[..]
    }
    
}

\end{lstlisting}

We can also create slice of array 

\begin{lstlisting}
    fn main(){
        let a = [1,2,3,4,5];
        let slice = &a[0..2]; // This is of type &[i32]
    }
\end{lstlisting}

\newpage

\section{Structs}
\subsection{Defining and Using Structs}
\begin{lstlisting}
//Defining a struct
    struct User{ 
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    //Creating an instance of struct
    let mut user1 = User {
        email: String::from("user@email.com"),
        username: String::from("user123"),
        active: true,
        sign_in_count: 1
    };
    let name = user1.username; // Get values from struct with the . operator
    user1.username = String::from("user234"); // modify specific values with . operator
  
    // Creating a new instance of struct with function
    let user2 = build_user(
        String::from("user345@email.com"),
        String::from("user345")
    );

    //We can also create new instances of a struct using existing instances.

    let user3 = User{
        email: String::from("user456@email.com"),
        username:String::from("user456"),
        ..user2 // Takes the remaining field from user2
    };

    // We can also create structs without naming fields, these are called tuple structs

    struct Colour(i32,i32,i32);
    struct Point(i32,i32,i32);

    // Colour and Point have the same fields, but have different type, 
    //so we can't pass a Colour to a function that expects a Point.

}

fn build_user(email: String, username: String) -> User {
    User{
        email, // Since functions arguments have same name as field names, can write it like this...
        username, //...This is called the field init shorthand syntax
        active: true,
        sign_in_count : 1,
    }
}
\end{lstlisting}
\newpage
\subsection{Methods}
\begin{lstlisting}
#[derive(Debug)] // Needed to print out, we will look more into this later.
struct Rectangle{
    width: u32,
    height: u32
}

// Creating implementation block for Rectangle struct,
// This will house function and methodes associated with struct

impl Rectangle{
    fn area(&self) -> u32{ // First arguement in method is always self, the instance the method is being called on
            self.width*self.height
    }

    fn can_hold(&self, other: &Rectangle) ->bool{
        self.width > other.width && self.height>other.height
    }
}

//Struct allow us to have multiple impl blocs

// We can also def associated function, unlike methods they aren't tied to an instance of our struct.

impl Rectangle{
    fn square(size: u32) -> Rectangle{
        Rectangle { 
            width: size, 
            height: size 
        }
    }
\end{lstlisting}

\section{Enums and Pattern matching}
Structs and enums are the building blocks for creating new types in Rust. In Rust, enums are most similar to the ones from functional programming.

\subsection{Defining Enums}
Enums allow us to enumerate a list of variants. When is it appropriate to use enums over structs?

\begin{example}
    In this example we use enums to enumerate IP adresses, an IP adresse can be one of only two types, version 4 and version 6. So it is natural to use enums 
if we want to express IP adresses in code.
\newpage
    \begin{lstlisting}
enum IpAddrKind {
    V4(u8, u8, u8, u8), // We can male this code more precise by adding data in the variant
    V6(String),   // Enum variants can store different types of data
}

enum Message{
    Quit,
    Move {x: i32, y: i32},
    Write(String),
    ChangeColor(i32,i32,i32),
}

//Just like strucs we can define methods and associated functions on enum type.

impl Message{
    fn some_fn(){
        println!("Ya-hoo");
    }
}


struct  IpAddr{
    kind: IpAddrKind,
    address: String,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    let localhost = IpAddrKind::V4(127,0,0,1);
}

//Since V4 and V6 are both variants of IpAddrKind, we can define a function that takes in
//our enum type, and it can take in either V4 or V6

fn route(ip_kind: IpAddrKind) {}
    \end{lstlisting}
\end{example}
\subsection{Option Enum}
Many languages have null values, a value can either exists or it is null (there is no value). But the type system cannot guarentee that if you use 
a value it is not null.

This is not a problem in Rust, since Rust has no null values. We use the option enum.

\begin{lstlisting}
fn main(){
    /*  If we have a value that can possibly be null, we wrap it in the options enum.
    enum Option<T>{
        Some(T), //Some store any value
        None, // None store no value
    }
    This forces the type system to enforce that we handle the None case and guarentees that a value exists in the Some case.*/
       
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None; // We need to annotate the type since no value is passed in so Rust can't infer the type.


    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    // let sum = x+y; This code gives an error, since we can't add i8 to an Option<i8>
        

    // In general we need to treat cases if Option is Some or None.

    let sum =x+y.unwrap_or(0); // If y is Some it adds, if y is None it treats it as if it was 0.
}
\end{lstlisting}

\subsection{Pattern Matching}

Recall, match allows us to compare a value to a set of values. This is very useful for enums.

\begin{lstlisting}
    //Using Match Expressions

fn main(){
    value_in_cents(Coin::Quarter(UsState::Alaska));
}

#[derive(Debug)]
enum UsState{
    Alabama,
    Alaska,
    Arizona,
    Arkansas,
    California,
    // ...
}

enum Coin{
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin:Coin) -> u8{
    match coin{
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
\end{lstlisting}
This program will output:\begin{verbatim}
    State quarter from Alaska!
\end{verbatim}

\begin{lstlisting}
    //Using Match Expressions with Option<T> enum

fn main(){
    let five = Some(5);
    let six = plus_one(5);
    let none = plus_one(None);
}

fn plus_one(x: Option<i32>) -> Option<i32>{
    match x{
        Some(i) => Some(i+1),
        None => None 
    }
}
/*
Note Match expressions are exhaustive so we need to match all possible values. So if we 
have a lot of types of values, we use the underscore placeholder.
    match x{
        Some(i) => Some(i+1),
        _=> None // underscore means if it is any other pattern execute this code.
    }
*/
\end{lstlisting}
\subsection{Using if let syntax}
\newpage
\begin{lstlisting}
    //Using if let syntax

fn main(){
    let some_value = Some(3);
// Instead of using the match like this, when we only have on case we care about.    
    match some_value{
        Some(3) => println!("three"),
        _=> (),
    }

// We can use the if-let synyax

    if let Some(3) = some_value{ // Says if some_value matches with Some(3) execute the bellow code
        println!("three");
    }
}
\end{lstlisting}
\end{document}