\input{template.tex}
\usepackage{fancyvrb, framed, verbatim}
\usepackage{listings}
\usepackage[T1]{fontenc}
\definecolor{shadecolor}{rgb}{.9, .9, .9}  %These were defined for when I used to use the verbatim environment, they are not used now normally.
\newenvironment{code} %
   {\snugshade\verbatim}%
   {\endverbatim\endsnugshade}



\lstset{ 
  language=C,
  backgroundcolor=\color[rgb]{0.1,0.1,0.1},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  showstringspaces=false,          % So that it hides the spaces in strings
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  firstnumber=1,                % start line enumeration with line 1
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{gray}, % the style that is used for the line-numbers
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  tabsize=2,	                   % sets default tabsize to 2 spaces
  commentstyle=\color{YellowGreen},    % comment style
  stringstyle=\color{DarkOrchid},     % string literal style
 % keywordstyle=\color{ForestGreen},       % keyword style
  upquote=true                     %Fixing the quotes
}

\pagecolor[rgb]{0.1,0.1,0.1} %page colour is frosted screen black
\color[rgb]{0,0.6,0} %text colour is phosphor green



\title{Rust Course notes}
\author{Razafy Rindra, ``Hagamena''}

\begin{document}

\maketitle
\tableofcontents
\newpage
\section{Introduction}
Some quick notes from the Rust book, and the ``Let's Get Rusty'' \href{https://youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8}{online course}
\section{Common Programming Concepts in Rust}
\subsection{Variables and Mutability}
\subsubsection{Mutable variables} 
Variables in Rust are immmutable by default. In order to createe a mutable variable, we need to add in `mut' in front of the name like so:
\begin{lstlisting}
    fn main() {
        let mut x = 5;
        println!("The value of x is: {x}");
        x = 6;
        println!("The value of x is: {x}"); 
}
\end{lstlisting}


\subsubsection{Constants} We can also declare constants in Rust like so:
\begin{lstlisting}
    const my_number: u32 = 100_000;
\end{lstlisting}

Constants unlike variables can't be mutable, need to be type annotated and they can't be assigned to return value of a function or any value computed at run time.

\subsubsection{Shadowing}
Shadowing allows us to create a new variable with an existing name, for example:
\begin{lstlisting}
    let x = 5;
    println!("The value of x is: {x}");
    let x = "six";
    println!("The value of x is: {x}");
\end{lstlisting}

\subsection{Data Types}
\begin{definition}
    \textbf{Scalar data types} represent a single value, \textbf{Compound data types} represent a goup of values
\end{definition}
Types of scalar data types\begin{enumerate}
    \item Integers, they can be 8,16,32,64,128 bit signed or unsigned integers.
    \item Floating-point numbers
    \item Booleans
    \item Character, they represent unicode character
\end{enumerate}
Type of compound data types\begin{enumerate}
    \item Tuples; a fixed size array of data that can be of different values.
    \begin{lstlisting}
        let tup = ("Let's Get Rusty!",100_000);
    \end{lstlisting}
    \item Arrays, in Rust they are fixed length.
\end{enumerate}
\subsection{Functions}
Functions are defined with an fn keyword like so:\begin{lstlisting}
    fn my_function(x: i32,y: i32){
         println!("The value of x is: {}", x);
         println!("The value of y is: {}", y);
    }
\end{lstlisting}

A piece in code in Rust are either a statement or an expression. Statements perform some action but do not return any value, whilst expressions returns values. 
\begin{lstlisting}
    fn my_function(x: i32,y: i32) -> i32{
         println!("The value of x is: {}", x);
         println!("The value of y is: {}", y);
         x+y
    }
\end{lstlisting}

In this function, the println are statements since they don't return anything while `x+y' is an expression, it is returned by the function (note the last expression of a function is implicitely returned). 

\subsection{Control Flow}
\subsubsection{if statements}
As in other programming languages:\begin{lstlisting}
 fn main() {
    let number = 3;

    if number < 5 {
        println!("first condition was true");
    } else if number < 22{
        println!("second condition was true.")
    }else{
        println!("condition was false");
    }
}
\end{lstlisting}
Note, the condition must be a boolean. We can also set a ``if-else'' statement in a let statemetn.\begin{lstlisting}
    fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
\end{lstlisting}
\subsubsection{Loops}
We can create loops with the `loop' keyword, which will execute the code in it until we call break.\begin{lstlisting}
    let mut counter = 0;
    let result = loop{
       counter += 1;
       if counter == 10{
            break counter;
       }
    };
\end{lstlisting}

We can also use the while statement:\begin{lstlisting}
    let mut number = 3;
    while number != 0{
        println!("{}!", number);
        number -= 1;
    }
\end{lstlisting}

Finally the third type of loop we can create are `for loops'\begin{lstlisting}
    let a = [10,20,30,40,50];
    
    for element in a.iter{
        println!("The value is: {}", element);
    }
\end{lstlisting}

We can also loop over a range:\begin{lstlisting}
    for number in 1..4{
        println!("{}!", number);
    }
\end{lstlisting}
The last number of the range is excluded.
\section{Ownership}
\paragraph*{What is ownership?}
The ownership model is a way to manage memory. How do we manage memory today?\begin{enumerate}
    \item Garbage collection.
Used in high level languages like java or $C\#$, the Garbage collection manages memory for you.
It's pros is that is error free, you don't have to manage memory yourself so you won't introduce memory bugs. It also faster write time.

It's cons is that you have no control over memory, it is slower and has unpredictable runtime performance and larger program size since you got to include a garbage collector.

    \item Manual memory management
    
It's pros are that you have higher control over memory, faster runtime and smaller program size. But it is error prone and has slower writing time.

Notice that these two have opposite trade-offs.

    \item Ownership model
    
This is the way Rust manages memory, it's pros are control over memory, faster runtime and smaller program size and is error free (though it does allow for you to opt-out of memory safetey).
It's cons is that you have a slower write time, slower than with Manual memeory management, Rust has a strict set of rules around memory management.
\end{enumerate}

\paragraph*{Stack and Heap}
During runetime program has access of stack and heap, stack is fixed size and cannot grow or shrink during runetime and it creates stack-frames for each function 
it executes. Each stack frames stores the local variables of the function they execute, their size are calculated during compile time and variables in stack frames 
only live as long as the stack lives.

\

The heap grows and shrinks during runtime and the data stored can be dynamic in size and we control the lifetime of the data.

Pushing to the stack is faster than allocating on the heap since the heap has to spend time looking for a place to store the data, also accessing data on the stack is faster 
than accessing data on the heap, since on the heap we must follow the pointer.

\begin{lstlisting}
    let x = "hello";
\end{lstlisting}
This is a string litteral and has fixed size and is stored in the stack-frame.

\begin{lstlisting}
    let x = String::from(world");
\end{lstlisting}
x is of type String which can be dynamic in size so it can't be stored on the stack, we ask the heap to allocate memory for it 
and it passes back a pointer, which is what is stored on the stack. 

\subsection{Ownership Rules}

\begin{enumerate}
    \item Each value in Rust has a variable called its owner.
    \item There can only be one owner at a time.
    \item When the owner goes out of scope, the value will be dropped.
\end{enumerate}

\begin{example}

    \

    \begin{lstlisting}
        fn main(){
            let x = 5;
            let y = x; // Copy

            let s1 = String::from("hello");
            let s2 = s1; // move (not a shallow copy)

            println!("{}, world", s1);
        }
    \end{lstlisting}
This returns an error since when we created s2 we made it point to the same ``hello'' on the heap that s1 points to, but in order to 
ensure memory safetey, Rust invalidates s1. 

What if we do want to clone the string? Use the clone() method: \begin{lstlisting}
    fn main(){
        let x = 5;
        let y = x; // Copy

        let s1 = String::from("hello");
        let s2 = s1.clone();

        println!("{}, world", s1);
    }
\end{lstlisting}
\end{example}

\subsection{Ownership and functions}
\begin{example}

    \

    \begin{lstlisting}
        fn main(){
            let s = String::from("hello);
            takes_ownership(s);
            println!("{}", s);
        }

        fn takes_ownership(some_string: String){
            println!("{}", some_string);
        }
    \end{lstlisting}

This gives us an error since after we pass a parameter in a function it is the same as if we assign the parameter to another variable.

So we move s into some\_string and after takes\_ownership scope is done some\_string is dropped.

\begin{example}
    
    \

    \begin{lstlisting}
        fn main() {
            let s1 = gives_ownership();
            println!("s1 = {}", s1);
        }

        fn gives_ownership(){
            let some_string = String::from("hello");
            some_string // returning the string moves ownership to s1
        }
    \end{lstlisting}
\end{example}
\begin{example}
    
    \

    \begin{lstlisting}
        fn main() {
        let s1 = gives_ownership();         // gives_ownership moves its return
                                            // value into s1
    
        let s2 = String::from("hello");     // s2 comes into scope
    
        let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                            // takes_and_gives_back, which also
                                            // moves its return value into s3
    } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
      // happens. s1 goes out of scope and is dropped.
    
    fn gives_ownership() -> String {             // gives_ownership will move its
                                                 // return value into the function
                                                 // that calls it
    
        let some_string = String::from("yours"); // some_string comes into scope
    
        some_string                              // some_string is returned and
                                                 // moves out to the calling
                                                 // function
    }
    
    // This function takes a String and returns one
    fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                          // scope
    
        a_string  // a_string is returned and moves out to the calling function
    }
    \end{lstlisting}
    

\end{example}

Moving ownership and giving back is tedious, what if we just want to use variable without taking ownership? Use references.

\end{example}
\subsection{References}

Let us see how references fix the following situation\begin{lstlisting}
    fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
\end{lstlisting}

Here in order to calculate the length of the string without taking ownershipe, we need to return a tuple that returns both the string and the length.

\begin{lstlisting}
    fn main() {
        let s1 = String::from("hello");
    
        let len = calculate_length(&s1);
    
        println!("The length of '{}' is {}.", s1, len);
    }
    
    fn calculate_length(s: &String) -> usize {
        let length = s.len(); // len() returns the length of a String
        length 
    }
\end{lstlisting}

Here s is a reference of a string and takes no ownership of the string, it points to s1 which points to the string.
So when the function finishes executing s is dropped without affecting s1.

\begin{definition}
    Passing in references as function paramaters is called \textbf{borrowing}. Since we are not taking ownership of the parameters.
\end{definition} 
Note that references are immutable by default, so how to we modify value without taking ownership?

Mutable references:

\begin{lstlisting}
    fn main() {
    let mut s1 = String::from("hello");

    change(&mut s1);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
\end{lstlisting}

Now change can mutate the value of s1 without taking ownership. Mutable reference have a restriction, we can only have one mutable reference to a particular piece of data 
in a particular scope.

\newpage

\begin{lstlisting}
    fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s; // Returns an error since can not borrow twice.

    println!("{}, {}", r1, r2);
}
\end{lstlisting}

This prevents ``data races'' where two pointers point at the same data and one pointer reads the data and another one tries to write to the data.


What if we try to mix mutable and immutable references? We get another error, we can't have mutable reference if an immutable referece already exists. Immuatble reference don't expect the underlying data to change.
But we can have many Immuatble references, since we don't expect the underlying value to change.

Note the scope of a reference starts when it introduced and ends when it's used for the last time, so we can define a mutable reference when all the immuatble references are out of scope(so after we use them for the last time).

\paragraph*{Rules of Refences}\begin{enumerate}
    \item At any given time, we can either have one mutable reference or any number of immuatble reference.
    \item References must always be valid.
\end{enumerate}

\subsection{Slices}

\begin{definition}
    Slices let you a contiguous sequence of elements in a collection instead of the whole collection, without taking ownership.
\end{definition}

\begin{lstlisting}
    fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

fn main() {}
\end{lstlisting}

There are two problems with this, the return value of first\_word is not tied to the string.
If we change the string, the value of the length of the first word doesn't change.

If we wanted to return the second word, we must retrurn a tuple with the index at the start of the word and the index at the end of the word.
We have more values we must keep in sync.

Let us use the string slice:

\begin{lstlisting}
    fn main() {
    let mut s = String::from("hello world");

    let hello = &s[..5]; //String Slices, tells us we want the value of the string from index 0 to 4
    let world = &s[6..]; //String Slices, tells us we want the value of the string from index 6 to 10
    
    let s2 = "hello word"; // String litteral are string slices!

    let word = first_word(s2);

    fn first_word(s: &str) -> &str {
        let bytes = s.as_bytes();
    
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &s[0..i];
            }
        }
    
        &s[..]
    }
    
}

\end{lstlisting}

We can also create slice of array 

\begin{lstlisting}
    fn main(){
        let a = [1,2,3,4,5];
        let slice = &a[0..2]; // This is of type &[i32]
    }
\end{lstlisting}

\newpage

\section{Structs}
\subsection{Defining and Using Structs}
\begin{lstlisting}
//Defining a struct
    struct User{ 
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    //Creating an instance of struct
    let mut user1 = User {
        email: String::from("user@email.com"),
        username: String::from("user123"),
        active: true,
        sign_in_count: 1
    };
    let name = user1.username; // Get values from struct with the . operator
    user1.username = String::from("user234"); // modify specific values with . operator
  
    // Creating a new instance of struct with function
    let user2 = build_user(
        String::from("user345@email.com"),
        String::from("user345")
    );

    //We can also create new instances of a struct using existing instances.

    let user3 = User{
        email: String::from("user456@email.com"),
        username:String::from("user456"),
        ..user2 // Takes the remaining field from user2
    };

    // We can also create structs without naming fields, these are called tuple structs

    struct Colour(i32,i32,i32);
    struct Point(i32,i32,i32);

    // Colour and Point have the same fields, but have different type, 
    //so we can't pass a Colour to a function that expects a Point.

}

fn build_user(email: String, username: String) -> User {
    User{
        email, // Since functions arguments have same name as field names, can write it like this...
        username, //...This is called the field init shorthand syntax
        active: true,
        sign_in_count : 1,
    }
}
\end{lstlisting}
\newpage
\subsection{Methods}
\begin{lstlisting}
#[derive(Debug)] // Needed to print out, we will look more into this later.
struct Rectangle{
    width: u32,
    height: u32
}

// Creating implementation block for Rectangle struct,
// This will house function and methodes associated with struct

impl Rectangle{
    fn area(&self) -> u32{ // First arguement in method is always self, the instance the method is being called on
            self.width*self.height
    }

    fn can_hold(&self, other: &Rectangle) ->bool{
        self.width > other.width && self.height>other.height
    }
}

//Struct allow us to have multiple impl blocs

// We can also def associated function, unlike methods they aren't tied to an instance of our struct.

impl Rectangle{
    fn square(size: u32) -> Rectangle{
        Rectangle { 
            width: size, 
            height: size 
        }
    }
\end{lstlisting}

\section{Enums and Pattern matching}
Structs and enums are the building blocks for creating new types in Rust. In Rust, enums are most similar to the ones from functional programming.

\subsection{Defining Enums}
Enums allow us to enumerate a list of variants. When is it appropriate to use enums over structs?

\begin{example}
    In this example we use enums to enumerate IP adresses, an IP adresse can be one of only two types, version 4 and version 6. So it is natural to use enums 
if we want to express IP adresses in code.
\newpage
    \begin{lstlisting}
enum IpAddrKind {
    V4(u8, u8, u8, u8), // We can male this code more precise by adding data in the variant
    V6(String),   // Enum variants can store different types of data
}

enum Message{
    Quit,
    Move {x: i32, y: i32},
    Write(String),
    ChangeColor(i32,i32,i32),
}

//Just like strucs we can define methods and associated functions on enum type.

impl Message{
    fn some_fn(){
        println!("Ya-hoo");
    }
}


struct  IpAddr{
    kind: IpAddrKind,
    address: String,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    let localhost = IpAddrKind::V4(127,0,0,1);
}

//Since V4 and V6 are both variants of IpAddrKind, we can define a function that takes in
//our enum type, and it can take in either V4 or V6

fn route(ip_kind: IpAddrKind) {}
    \end{lstlisting}
\end{example}
\subsection{Option Enum}
Many languages have null values, a value can either exists or it is null (there is no value). But the type system cannot guarentee that if you use 
a value it is not null.

This is not a problem in Rust, since Rust has no null values. We use the option enum.

\begin{lstlisting}
fn main(){
    /*  If we have a value that can possibly be null, we wrap it in the options enum.
    enum Option<T>{
        Some(T), //Some store any value
        None, // None store no value
    }
    This forces the type system to enforce that we handle the None case and guarentees that a value exists in the Some case.*/
       
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None; // We need to annotate the type since no value is passed in so Rust can't infer the type.


    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    // let sum = x+y; This code gives an error, since we can't add i8 to an Option<i8>
        

    // In general we need to treat cases if Option is Some or None.

    let sum =x+y.unwrap_or(0); // If y is Some it adds, if y is None it treats it as if it was 0.
}
\end{lstlisting}

\subsection{Pattern Matching}

Recall, match allows us to compare a value to a set of values. This is very useful for enums.

\begin{lstlisting}
    //Using Match Expressions

fn main(){
    value_in_cents(Coin::Quarter(UsState::Alaska));
}

#[derive(Debug)]
enum UsState{
    Alabama,
    Alaska,
    Arizona,
    Arkansas,
    California,
    // ...
}

enum Coin{
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin:Coin) -> u8{
    match coin{
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
\end{lstlisting}
This program will output:\begin{verbatim}
    State quarter from Alaska!
\end{verbatim}

\begin{lstlisting}
    //Using Match Expressions with Option<T> enum

fn main(){
    let five = Some(5);
    let six = plus_one(5);
    let none = plus_one(None);
}

fn plus_one(x: Option<i32>) -> Option<i32>{
    match x{
        Some(i) => Some(i+1),
        None => None 
    }
}
/*
Note Match expressions are exhaustive so we need to match all possible values. So if we 
have a lot of types of values, we use the underscore placeholder.
    match x{
        Some(i) => Some(i+1),
        _=> None // underscore means if it is any other pattern execute this code.
    }
*/
\end{lstlisting}
\subsection{Using if let syntax}
\newpage
\begin{lstlisting}
    //Using if let syntax

fn main(){
    let some_value = Some(3);
// Instead of using the match like this, when we only have on case we care about.    
    match some_value{
        Some(3) => println!("three"),
        _=> (),
    }

// We can use the if-let synyax

    if let Some(3) = some_value{ // Says if some_value matches with Some(3) execute the bellow code
        println!("three");
    }
}
\end{lstlisting}

\section{Module}
In previous courses we have just been writting our code in one file, but now we are going to learn to be more organised, we will learn rust's Module system.
\subsection{Packages and Crates}
\begin{definition}
    \textbf{Crates}:

    When we type ``Cargo new'', Rust creates a new package containing crates, which contain modules.

    Crates come in two flavours:\begin{itemize}
        \item Binary crate: Code you can execute
        \item Library crate: Code that can be used by other programs.
    \end{itemize}
\end{definition}

Convention:
If we have ``main.rs'' file in the src directory then a binary crate with the same name as package will be automatically created and main.rs will be the crate root.

\begin{definition}
    \textbf{Crate root}

    Is the source file that rust compiler starts at when building our crate.
\end{definition}

If we have ``lib.rs'' file in the src directory then a library crate with the same name as package will be automatically created and lib.rs will be the crate root.

\paragraph*{Rules around crates}
\begin{itemize}
    \item A package must have at least one crate
    \item A package can have either 0 or 1 library crate
    \item A package can have any number binary crate.
\end{itemize}

If want to make more binary crates, make a folder called bin, each file in that folder will represent another binary crate.


\subsection{Defining Modules}
\newpage
\subsubsection{Definintions, Paths and Privacy}
\begin{lstlisting}
    //Our goal is to create library that helps run a restaurant.

    //We seperate the restaurant in two parts, the front of the house is where the customers are
    //Back of the house is where food is being made, dishes are clean and where manager is.

    mod front_of_house { // module are specified with mod keyword
    // In side this module we have two other modules, modules can contain other modules, structs, enums, constants, traits, etc...
    
    pub mod hosting { //By default a child module and anything inside of it is private from the point of view of parent module.  
    // So need to put the "pub" keyword, so that front_of_house can see hosting and it's contents.
        pub fn add_to_waitlist() {}

            fn seat_at_table() {}
        }

        mod serving {
            fn take_order() {}

            fn serve_order() {}

            fn take_payment() {}
        }
    }


    // If you want to reference an item in module tree (like a funciton), need to specifyt a path to function
    pub fn eat_at_restaurant(){
        // Absolute path
        crate::front_of_house::hosting::add_to_waitlist();

        //Relative path, start from the current module
        front_of_house::hosting::add_to_waitlist();

    }

    fn serve_order(){}

    mod back_of_house{
        fn fix_incorrect_order(){
            cook_order();
            super::serve_order(); // super:: allows us to reference the parent module, in this case crate.
        }

        fn cook_order() {}
    }
\end{lstlisting}
\newpage 

\subsection{Privacy rules when it comes to structs}

\begin{lstlisting}
    //Privacy rules when it comes to structs

    mod back_of_house {
        pub struct Breakfast { // Need to pub keyword to access it.
        pub toast: String, // Even though struct is pub, by default fields are private 
        seasonal_fruit: String,
        }

        impl Breakfast {
            pub fn summer(toast: &str) -> Breakfast {
                Breakfast {
                    toast: String::from(toast),
                    seasonal_fruit: String::from("peaches"),
                }
            }
        }
    }

    pub fn eat_at_restaurant() {
        let mut meal = 
            back_of_house::Breakfast::summer("Rye");
        
        meal.toast = String::from("Wheat");
        
        // Note we need to use summer function to make Breakfast struct.
        // We can't create one directly, since it contains a private field, seasonal_fruit.

        /*
        This gives us an error 
        
        let meal2 = back_of_house::Breakfast{
            toast: String::from("Wheat"),
            seasonal_fruit: String::from("peaches")
        };
        */
    }
\end{lstlisting}

\newpage
\subsubsection{Privacy rules when it comes to enums}

\begin{lstlisting}
    mod back_of_house {
    pub enum Appetizer { 
        Soup, // By default if an enum is public so are it's variants.
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
\end{lstlisting}

\newpage
\subsubsection{Use keyword}
\paragraph*{Bringing paths into scope with the use keyword.}

\begin{lstlisting}
    mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// In order to not have to specify the whole path to add_to_waitlist each time we call it, we can use the "use" keyword to bring a path in to scope.

// use self::front_of_house::hosting; relative path with "self" referenceing the current module 

pub use crate::front_of_house::hosting; // If we want code that is external to this file to reference hosting::, we need to mark this "pub"


pub fn eat_at_restaurant() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}




/*  Could have brought the funtion into scope to not have to use hosting::
 But in Rust the idiomatic way to bring a function into scope is to bring it's parent module into scope
 In order to make it clear that add_to_waitlist() function is not a local function.

 If we are bringing enums, struct, other items into scope then we specify the whole path. Except if we are bringing two items with the same name into scope.

For example here:


use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
    Ok(())
}

fn function2() -> io::Result<()> {
    // --snip--
    Ok(())
}

Another way of doing this is to rename our function:

use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
*/
\end{lstlisting}
\newpage 
\paragraph*{Using external packages}
\begin{lstlisting}
    //Use keyword

    /*Instead of this:
    use rand::Rng;
    use rand::CryptoRng;
    use rand::ErrorKind::Transient;
    We can do this:
    */
    
    use rand::{Rng, CryptoRng, ErrorKind::Transient}; // Nested paths
    
     
    /*
    Instead of this:
    use std::io
    use std::io::Write
    
    We can do this:
    
    */
    
    use std::io::{self, Write};
    
    
    //Glob operator:
    // use std::io::* this means all public items underneath io are in scope.     
\end{lstlisting}

\newpage
\subsubsection{Modules in sperate files}
In order to make our code cleaner we can move our module definitions in different files:
\begin{lstlisting}
// In src/lib.rs
mod front_of_house; // This tells Rust, define our module here but get the contents from a different file with the same name as our module.


pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
\end{lstlisting}

\begin{lstlisting}
//In src/front_of_house.rs

    pub mod hosting;
\end{lstlisting}

\begin{lstlisting}
// In src/front_of_house/hosting.rs

    pub fn add_to_waitlist() {} // Needs to live in a directory with the same name as parent module.        
\end{lstlisting}

\section{Common Collections}
\begin{definition}
    \textbf{Collection}
These are some useful data structures included in the standard library.

\

Unlike arrays and tuples, collections are allocated on the heap so their size can grow or shrink as needed.
\end{definition}

In this section we will talk about vectors, strings and hashmaps.

\subsection{Vectors}
\begin{lstlisting}
    fn main() {
//Vectors
    let a = [1,2,3];
    let mut v:Vec<i32> = Vec::new(); //Vectors can hold any values, so we need to specify the type.
    v.push(1); // Vectors can grow in size, we can add eleements to it with .push()
    v.push(2);
    v.push(3);

    {
        let v2 = vec![1,2,3]; // Can create a vector with initial values like this.
    }// When our scope ends, v2 and all elements in it are dropped.

//Acessing elemetents in vectors

    let mut v = vec![1,2,3,4,5];

    let third = &v[2];
    //  v.push(6);  Error since v is borred as immutable on previous line. If we have an immutable reference to something we expect the underlying value to not change. But if we take a mutable reference to the same thing, the underlying value could change.
    // When we push an element to a vector, we may need to allocated more memory for the new element, so we would move all elements in vector to new location, and our element at the previous line will be pointing to something else.
    println!("The third element is {}", third);

    // If we try to run with third = &v[20], we will get a runtime error, unlike with arrays, we don't get a compile time error. Since at compile time we don't know the size of vector. 

    //If we want to access data gracefully, so that the program doesn't crash at runtime if an invalid index is used.

    match v.get(20) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }

//Iterating over vector.

    for i in &mut v{ // for loop
        *i += 50; // Derefencing operator
        println!("{}", i);
    }

// Storing enum variables

    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];

    match &row[1] {
        SpreadsheetCell::Int(i) => println!("{}", i),
        _=> println!("Not an integer!")
    };
}
\end{lstlisting}

\subsection{String}

In higher programming languages, the complexity of strings is abstracted away from the programmer. In lower programming languages, like in Rust, we have to deal with 
that complexity.

\begin{definition}
    \textbf{Strings} are stored as a collection of UTF-8 encoded bytes. 
\end{definition}

What is UTF-8 encoding? We first need to understand ASCII, it is an string encoding. It defines how to take $10's$ and turn them into strings and vice-versa.

Each ASCII character is stored as a byte, and only 7-bits of that byte is used to represent a character. So only 128 unique characters.
It only represents the english alphabet, some special characters and commands.

\

So other countries came up with their own standards to encode characters. So how does a program know what standard to use when interpratating a collection of bytes.

So unicode was created was used to solve this problem. Unicode represent characters from a lot of languages, and other characters like emojis. It is also backwards compatible with ASCII.

\begin{definition}
    \textbf{UTF-8} is a ``variable-width'' character encoding. Each character in UFT-8 can be represented by 1 byte, 2 bytes, 2 bytes or 4 bytes. 
\end{definition}

\paragraph*{Three relevant ways a string is represented in unicode.}


\begin{itemize}
    \item bytes
    \item Scalar values, can think about these as building blocks of characters (this is what the char type refers to). They can be characters or parts of characters.
    \item Grapheme clusters, what we usually mean when we say characters, the glyphs that build up a word. 
\end{itemize}

The problem with indexing into a string Rust doesn't know what value we want to recieve. Bytes, scalaing values or grapheme clusters.

Look at the /collection-strings folder to see the code.

\subsection{Hash maps}

\begin{definition}
    \textbf{Hash maps} allow us to store key-value pairs and uses a hashing function to determine how to place the keys and values.
\end{definition}

\begin{lstlisting}
    use std::collections::HashMap;

fn main() {
    let blue = String::from("Blue");
    let yellow = String::from("Yellow");

    let mut scores = HashMap::new();

    scores.insert(blue, 10); //Note we are not passing the strings as references, so we transfer ownership into the hashmap
    scores.insert(yellow,50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name); //Get method takes a reference to a key and gives us an option, since we can't guarentee a value will be returned, if we pass an invalide key it will return None.

    for (key, value) in &scores{
        println!("{}: {}", key, value);
    }

    println!("-------");

// Updating our Hashmap

    scores.insert(String::from("Blue"), 20); // Overwrites the Blue key with the value 20.

    //If we don't run to overwrite the existing values:

    scores.entry(String::from("Green")).or_insert(30); //If there isn't entry for key insert key with value 30 unless do nothing.
    scores.entry(String::from("Green")).or_insert(40); //Nothing happens here.

    for (key, value) in &scores{
        println!("{}: {}", key, value);
    }
    
    println!("---");

// Updating values based on old value

    let text = "hello world wonderful world";
    // value is how many times the key appears in the string.
    let mut map = HashMap::new();


    //["hello", "world", "wonderful", "word"]
    for word in text.split_whitespace() { //Splits up the string by the whitespace
        let count = map.entry(word).or_insert(0); // .entry retirns an enum representing the value at that key. If the word doesn't exists it adds it to the hashmap and initialises the value to 0. If it does exists it doesn't do anything.
        *count += 1; //or_insert returns a mutable reference to our value, so we can deincrement it and add 1, even if it doesn't do anything sine the key already exists.
    }

    println!("{:?}", map);

}
\end{lstlisting}

\end{document}